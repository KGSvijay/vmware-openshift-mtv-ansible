---
# Step 1: Build a list of all the folders
- name: Build a list of all the folders
  vmware.vmware_rest.vcenter_folder_info:
    vcenter_hostname: "{{ vcenter_hostname }}"
    vcenter_username: "{{ vcenter_username }}"
    vcenter_password: "{{ vcenter_password }}"
    vcenter_validate_certs: no
  register: all_folders

# Step 2: Filter VM folders
- name: Filter VM folders
  ansible.builtin.set_fact:
    vm_folders: "{{ all_folders.value | selectattr('type', 'equalto', 'VIRTUAL_MACHINE') | list }}"

- name: Debug vm_folders
  ansible.builtin.debug:
    msg: "{{ vm_folders }}"

# Step 3: Check each VM folder for VMs
- name: Check each VM folder for VMs
  vmware.vmware_rest.vcenter_vm_info:
    folders: "{{ item.folder }}"
    vcenter_hostname: "{{ vcenter_hostname }}"
    vcenter_username: "{{ vcenter_username }}"
    vcenter_password: "{{ vcenter_password }}"
    vcenter_validate_certs: no
  register: vm_folders_with_vms
  loop: "{{ vm_folders }}"
  when: vm_folders | length > 0

- name: Debug VM folder information
  ansible.builtin.debug:
    msg: "{{ vm_folders_with_vms }}"

# Step 4: Display VM names and IDs
- name: Display VM names and IDs
  ansible.builtin.debug:
    msg: "VM Name: {{ item.name }}, VM ID: {{ item.vm }}"
  loop: "{{ vm_folders_with_vms.results | map(attribute='value') | flatten }}"
  when: item | length > 0
  loop_control:
    label: "{{ item.name }}"

# Step 5: Collect VM names and IDs
- name: Collect VM names and IDs
  ansible.builtin.set_fact:
    vm_name_id_pairs: "{{ vm_name_id_pairs | default([]) + [{'name': item.name, 'vm': item.vm}] }}"
  loop: "{{ vm_folders_with_vms.results | map(attribute='value') | flatten }}"
  when: item | length > 0

# Step 6: Prepare VMs for Plan spec
- name: Prepare VMs for Plan spec
  ansible.builtin.set_fact:
    vms_for_plan_spec: "{{ vms_for_plan_spec | default([]) + [{'hooks': [], 'id': vm_id.vm}] }}"
  loop: "{{ vm_name_id_pairs }}"
  loop_control:
    loop_var: vm_id
  when: vm_id.name in user_selected_vm_names.split('\n')

# Step 7: Fetch Network Information
- name: Get the distributed port group information
  vmware.vmware_rest.vcenter_network_info:
    vcenter_hostname: "{{ vcenter_hostname }}"
    vcenter_username: "{{ vcenter_username }}"
    vcenter_password: "{{ vcenter_password }}"
    vcenter_validate_certs: no
    filter_types: DISTRIBUTED_PORTGROUP
  register: my_portgroup

- name: Capture the distributed portgroup id to make network mappings
  ansible.builtin.set_fact:
    portgroup_id: "{{ my_portgroup.value[0].network }}"

# Step 8: Create or update a NetworkMap
- name: Create or update a NetworkMap
  redhat.openshift.k8s:
    state: present
    definition:
      apiVersion: forklift.konveyor.io/v1beta1
      kind: NetworkMap
      metadata:
        name: "{{ networkmap_name }}"
        namespace: apm0002135-non-prod
      spec:
        map:
          - destination:
              type: pod
            source:
              id: "{{ portgroup_id }}"
        provider:
          destination:
            name: local-cluster
            namespace: apm0002135-non-prod
          source:
            name: " {{ vmware_host }} "
            namespace: apm0002135-non-prod

# Step 9: Fetch Datastore Information
- name: Build a list of all the datastores
  vmware.vmware_rest.vcenter_datastore_info:
  register: all_datastores

- name: Debug all_datastores
  ansible.builtin.debug:
    msg: "{{ all_datastores }}"

# Step 10: Collect Detailed VM Information Including Datastores
- name: Fetch detailed information about VMs including datastores
  vmware.vmware_rest.vcenter_vm_info:
    vcenter_hostname: "{{ vcenter_hostname }}"
    vcenter_username: "{{ vcenter_username }}"
    vcenter_password: "{{ vcenter_password }}"
    vcenter_validate_certs: no
    names: "{{ user_selected_vm_list }}"
  register: vm_details

- name: Debug vm_details
  ansible.builtin.debug:
    msg: "{{ vm_details }}"

# Step 11: Match and Collect Specific Datastore IDs
- name: Collect datastore info used by VMs
  ansible.builtin.set_fact:
    vm_datastores: >
      {{
        vm_details.value |
        map(attribute='datastores') |
        flatten |
        unique |
        select('defined') |
        list
      }}

- name: Debug Collect VM Datastores
  ansible.builtin.debug:
    msg: "{{ vm_datastores }}"

# Step 12: Match Datastores with Collected Datastore IDs
- name: Map VM datastores to datastore IDs
  ansible.builtin.set_fact:
    mapped_datastores: "{{ mapped_datastores | default([]) + [{'name': item.name, 'datastore_id': item.datastore}] }}"
  loop: "{{ all_datastores.value }}"
  when: "item.datastore in vm_datastores"

- name: Debug Mapped Datastores
  ansible.builtin.debug:
    msg: "{{ mapped_datastores }}"

# Step 13: Create or update a StorageMap for each datastore used by VMs
- name: Create or update a StorageMap for each unique datastore
  redhat.openshift.k8s:
    state: present
    definition:
      apiVersion: forklift.konveyor.io/v1beta1
      kind: StorageMap
      metadata:
        name: "{{ storagemap_name }}-{{ loop.index }}"
        namespace: apm0002135-non-prod
      spec:
        map:
          - destination:
              storageClass: portworx-rwx-kubevirt
            source:
              id: "{{ item.datastore_id }}"
        provider:
          destination:
            name: local-cluster
            namespace: apm0002135-non-prod
          source:
            name: " {{ vmware_host }} "
            namespace: apm0002135-non-prod
  loop: "{{ mapped_datastores }}"
  loop_control:
    label: "{{ item.name }}"

# Step 14: Deploy the Virtualization Plan
- name: Deploy Virt Plan
  redhat.openshift.k8s:
    state: present
    definition:
      apiVersion: forklift.konveyor.io/v1beta1
      kind: Plan
      metadata:
        name: "{{ plan_name }}"
        namespace: apm0002135-non-prod
      spec:
        archived: false
        description: ''
        map:
          network:
            name: "{{ networkmap_name }}"
            namespace: apm0002135-non-prod
          storage:
            name: "{{ storagemap_name }}"
            namespace: apm0002135-non-prod
        provider:
          destination:
            name: local-cluster
            namespace: apm0002135-non-prod
          source:
            name: " {{ vmware_host }} "
            namespace: apm0002135-non-prod
        targetNamespace: apm0002135-non-prod
        vms: "{{ vms_for_plan_spec }}"
        warm: false

# Step 15: Create a Migration Manifest to Run the Plan CR
- name: Create a Migration manifest to run the Plan CR
  redhat.openshift.k8s:
    api_version: forklift.konveyor.io.v1beta1
    kind: Migration
    namespace: apm0002135-non-prod
    name: "{{ plan_name }}"
    definition:
      metadata:
        name: "{{ plan_name }}"
        namespace: apm0002135-non-prod
      spec:
        plan:
          name: "{{ plan_name }}"
          namespace: apm0002135-non-prod
